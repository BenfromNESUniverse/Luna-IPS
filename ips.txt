Brette's consumable documentation on IPS (International Patching Standard) files.

#######################################################################
##                      Lesson 0 : Explanation                       ##
#######################################################################

IPS files, or International Patching Standard files, are files which contain information for modifying another file in a specified way.
IPS files are typically created by comparing two files together to find the differences between them and note said differences in an organized way.
Alot of the ROMhacking community is dependant on IPS files, which are within their own regard not illegal, whereas piracy is.
However, while an IPS file may not contain any illegal data - and may not itself be illegal as a file by any common law, often they are quite legally
removed by the owners of the material the files intend to modify. This is because IPS files thrive as a result of DMCA violation, that is to say
even dumping a game is illegal as you are making a duplicate and unauthorized copy.

Even many of the oldest popular retro games are not in the public domain, as it stands even if it is in your country - in the United States of America
the rules are likely to be stricter, and any sort of file sharing of sensitive data is strictly prohibited. Sharing game modding data or tools encourages
acts of DMCA violation and violates the integrity of sensitive distributed intellectual property.

IPS files can modify files up to 16,842,750 bytes in size (~16.8 MB) | 

This means that they can only modify contextually relatively small files for this modern day, meaning that there common targets are older devices.

One of the common uses for IPS files are the modification of Nintendo and Sony games on the internet, which is in and of itself illegal.
These files are used to transport the modifications for a file without storing the original content of the file itself.
The reasons that they are designed like this is two reduce filesize, but mainly for public distribution without containing sensitive media.

In this significantly technologically progressed world there are still those who uphold the virtue of anti-piracy and for this the use of IPS has prolonged.
Whether you use this knowledge to assist piracy or to defeat it, I hope you learn something technical from this and get a better understanding about how this works.

If you have any questions please feel free to ask on Discord : https://discord.gg/QYsHh97r4b

#######################################################################
##                     Lesson 1 : File structure                     ##
#######################################################################

IPS files are the simplest form of the modding file, simply storing where in memory to modify, the length of the data to insert and the data itself.

IPS files are build with many "Patch Instances" which contain an offfset, the length of the data, and the data itself to be wrote to the base file.
There are two types of Patch Instance which we will go over in detail.

Type 1 : (noRLE)

3 bytes are dedicated to offset, being the address to write the data to.
2 bytes are dedicated to length, being how long the data is (used to tell how far to read ahead for next patch instance)
x bytes are dedicated to the data itself, this length is determined by the previous two bytes.

Type 2 : (RLE)

3 bytes are dedicated to offset, being teh address to write the data to.
2 zero bytes are wrote, this shows that this is not a noRLE Patch Instance.
2 bytes are dedicated to RLE length, being how many times the following byte should loop to create the target data.
1 byte is the data itself, being looped x times defined by the preceeding RLE length bytes.

Example of a noRLE Patch Instance : AB CD EF 00 08 01 23 45 67 89 AB CD EF 
									|OFFSET||SIZE||Data ...		         |
Example of a RLe Patch Instance   : AB CD EF 00 00 FF FF 32
									|OFFSET||ZERO||SIZE|BYTE|

The Second Patch Instance actually write 65535 bytes to memory at 0xabcdef, whereas the First Patch Instance only writes 8 bytes.

The First Patch Instance will always cost 5 + (length byte) bytes to write.
The Second Patch Instanec will always cost 8 bytes.

One final to thing to note is that a Patch FILE will always start "PATCH" and end "EOF".

Example of a Patch File with everything we have learned:

80 65 84 67 72 AB CD EF 00 08 01 23 45 67 89 AB CD EF AB CD EF 00 00 FF FF 32 69 79 70
P  A  T  C  H  |OFFSET||SIZE |DATA...				  |OFFSET||ZERO||SIZE|BYTE|E  O  F

########################################################################
##                     Lesson 2 : Patching an IPS                     ##
########################################################################

In order to patch an IPS file to a base file we need to ensure that the file is not larger than 16,842,750

We can check with:

######################################
with open(base,"rb") as checksize::
	size = len(checksize.read())
if size > 16842750:
	return False,"File is too large"	#Error report with context

######################################

Now that we know the length of the file is within IPS range we can start to modify it.
We must obtain a bytearray of the base file as well as the IPS file.

This can be done like this:

######################################
with open(base,"rb") as getbase:
	basedata = getbase.read()
with open(mod, "rb") as getmod:
	moddata = getmod.read()
######################################

Now that we have both our files stored in RAM as bytearrays we can move onto normalizing the data.
All this involves is reading the file and converting the data into a more readable format.

We need to ensure that we have read up to the last byte of the IPS, if we haven't then that means there is a flaw in our logic and therefore our code.
But since we don't know how many times we need to iterate we will use a while loop with a temporary variable.

######################################
def patchrom(patch : bytes, rom : bytes):
	count, changes, patch, build = b"", 0, {}, patch[5:-3]

		#Where "patch" refers to the IPS bytearray
		#and "rom" refers to the base bytearray.
	while count != len(patch):

######################################

Changes will store all our changes in the format {offset : data}, RLE's benefits are very minimal for a PC with modern hardware specifications and can be ignored.
The Length bytes are now just information for reading data and require no more attention.
We are also redefining the patch bytearray to itself with its "PATCH" and "EOF" data trimmed of so the while loop works.
Build is the empty bytarray that will be the result of the writing process at the end of this all.


We will also use this subroutine below to convert an array of bytes into an integer to speed up the normalization process and create a smaller module:

#######################################

def bytestoint(bytelist):  #Accept bytearray
  build = ""
  for i in range(0, len(bytelist)):  #For each byte
    build += ("0" * (2 - len(hex(bytelist[i])[2:]))) + hex(bytelist[i])[2:]
  return int(build, base=16)

#######################################

  And using this function we can now get the offset value from the IPS Patch Instance and the size bytes (or RLE determiner bytes) easily.

#######################################

  offset = bytestoint(patch[count:count + 3])
  if patch[count + 3] > 0 or patch[count + 4] > 0:

#######################################

Given that the OR statement above works, we can confirm that this is not being used to determine RLE and refers to the length of data for noRLE:
Below we can see the code for appending noRLE data, this is done by retrieving the size byte and then handling the data from out current position
with added 5 byte tax for noRLE setup to the end of the leading bytes determined by size.
#######################################
  size = bytestoint(patch[count + 3:count + 5])
            changes[offset] = patch[count + 5:count + size + 5]
            count += size + 5
########################################

However given that the OR logic from above fails that means we are reading the RLE determiner byte and therefore we are now reading psot 7 bytes of data in tax.
Since the data byte itself is a standalone byte that means when writing data we have to interact with the length byte to exent the one length bytearray to size length bytes.

########################################

else:  #Handle RLE, only if NON-RLE is not met
            size = bytestoint(patch[count + 5:count + 7])
            changes[offset] = bytes([patch[count + 7]]) * size
            count += 8
########################################

The final bit is the most efficient and compresesd but works flawlessly in a majestic way:

########################################
for i in changes.keys():
     if i <= len(rom):
        build += rom[len(build):i]
     else:
        build += b"\x00" * (i - len(build))
     build += changes[i]
if len(build) < len(rom):
    build += rom[len(build):]
#########################################

For each offset (the keys of the changes dictionary)
if the offset is within the range of the base data, append rom data up until our target offset to this position.
Else, write blank zeroes until we reach the targt offset.
Then add the changes that belong to our target offset here.

This will loop until the last Patch Instance has been wrote, this of course could be anywhere within the base rom and therefore we need to add the check
that the modified file is at least the same size as the base file, else it writes the rest of the base data to the modded file.


The "build" variable is then returned from the "patchrom" variable and the result is presented for whatever application you intend to use this for.


#############################################################################
##                     Lesson 3 : Creating a Legal IPS                     ##
#############################################################################

This lesson will explain how to create a legal IPS, that being it under no circumstances keeps data from the base game even if it is present in the mod.
While this may sound like a trivial choice to save on data, there are few circumstances in which it is cheaper to store this information instead of paying byte tax.

This focuses mainly on creating a legal IPS in the name of counter-piracy rather than data opimizations.






Brette <3 https://discord.gg/QYsHh97r4b



